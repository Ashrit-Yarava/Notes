{"entityMap":{},"blocks":[{"key":"60q8h","text":"Abstract","type":"header-one","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"c6qv2","text":"Spectrum-based fault localization (SBFL) is one popular coverage based FL algorithm. It uses the test coverage to identify the most suspicious code elements. Other FL approaches (LLM, DL) also make use of the test suite to determine the faulty code elements. As a result, the quality of a test suite plays a major role in FL performance. Tests are usually written to maximize coverage and ignore their impact on FL. The proposed algorithm uses LLMs to introduce new unit tests to improve FL.","type":"unstyled","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"bubhe","text":"Background","type":"header-one","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"fflap","text":"Fault Localization","type":"header-two","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"b6h0f","text":"Fault localization (FL) aims to find the faulty element in a codebase. A variety of approaches exist to tackle this problem. LLM-based approaches [6, 7, 8] use LLMs to identify faulty methods through LLM analysis of code. [9] makes use of deep learning to identify relationships between methods for FL. One shared trait between these approaches is their reliance on the test suite for FL.","type":"unstyled","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"b72m5","text":"Spectrum Based Fault Localization","type":"header-three","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"1nmki","text":"SBFL is a coverage based FL algorithm that relies on the test coverage of passing and failing tests. Ranking functions such as Ochiai make use of these counts to assign suspiciousness. It works at different levels of granularity such as class, method or line level.","type":"unstyled","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"4mpvu","text":"","type":"unstyled","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"6vbcg","text":"A variety of algorithms make use of SBFL as the basis for tasks such as automated program repair (APR). In fact, [1] finds that almost all APR tools make use of SBFL in the FL step. These approaches use SBFL due to the efficiency and speed that the algorithm offers. The paper also identifies that limited SBFL performance hinders APR. As such, improving SBFL is a key research field and has implications for a variety of other fields.","type":"unstyled","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"1s3bg","text":"Test Generation for FL","type":"header-two","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"d0eil","text":"[2] introduced the idea of basic blocks, and their detrimental impact on FL. Basic blocks are sets of elements that have the same test coverage. In SBFL, having the same test coverage means having the same suspiciousness score. Large basic blocks can result in ties where a set of elements have equal suspiciousness. [2] proposes that tests generated with FL in mind should aim to maximize basic blocks in the codebase. The authors tackle the problem of test generation for FL with genetic algorithms. While useful, genetic algorithms (GA) are unable to generate complex tests.","type":"unstyled","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"fdi7h","text":"","type":"unstyled","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"6o3st","text":"Another explored approach [CITE] breaks down existing test cases to smaller subcomponents. Through this breakdown, the test cases are \"purified.\" The increase in test cases also splits the execution paths increasing basic blocks.","type":"unstyled","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"8b2cg","text":"LLM-Based Test Generation","type":"header-two","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"c4j2i","text":"The advent of powerful LLMs such as ChatGPT and DeepSeek have seen their use in a variety of SWE tasks. [3, 4, 5] show that LLMs can generate complex tests and outperform classical approaches. These approaches focus on maximizing text coverage and ignore FL performance.","type":"unstyled","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"d13s4","text":"Primary Contribution","type":"header-two","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"4p1v9","text":"While there is active research in test generation and FL, there is a gap on how to improve FL with test generation. The proposed algorithm evaluates how test generation can impact FL algorithms.","type":"unstyled","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"6ecuu","text":"","type":"unstyled","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"3p6v9","text":"The proposed algorithm aims to bridge the gap between test generation and FL. The proposed approach tackles improving the quality of the test suite. As a result, it will improve many FL approaches.","type":"unstyled","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"c3vi0","text":"","type":"unstyled","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"ea5jf","text":"Planned Approach","type":"header-one","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"2m8u7","text":"Overview","type":"header-two","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"37ad4","text":"The algorithm consists of three components. The first component, bug report generation, summarizes the failing tests and stack traces. Basic block identification and selection is the next step. It involves constructing basic blocks using the test coverage. The Ochiai function determines the suspiciousness scores for each basic block. The most suspicious basic block is then selected for test generation. The third step, test generation, generates a unit test for each method in the basic block. Failing tests are more valuable for FL than passing tests. As such, the step generates tests to search for a possible failing tests. The loop stops when a condition passes to ensure the algorithm does not waste energy. The LLM is also given the bug report to encourage generating fault-relevant tests. The algorithm is then evaluated on a variety of FL approaches.","type":"unstyled","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"nfv2","text":"Experimental Design","type":"header-two","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"8gttt","text":"We test the algorithm on the Defects4J v3.0 dataset, a collection of java projects. For each project, we record the original FL performance. We run the algorithm and record the changed FL performance to track improvement. We use the SBFL, AutoFL, and GRACE algorithms for evaluation of test generation. We test FL performance on the top@k and MFR metrics. We do not include the MAR metric since the algorithm only optimizes the first basic block. As such, it is likely that the first basic block might not contain all faulty methods. Finally, there will be an ablation study to identify the impact of components.","type":"unstyled","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"226l5","text":"Tools and Techniques","type":"header-two","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"90p8n","text":"We write the algorithm in Java and explore a variety of LLMs for the test generation step. We use SootUp and JavaParser for parsing the java code and use static analysis for test coverage.","type":"unstyled","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"997k7","text":"Potential Challenges","type":"header-two","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"1c6c2","text":"There are a list of possible approaches for the stop condition in test generation. Each of these approaches should explored. The first approach involves comparing execution paths between existing and new tests. The second approach involves comparing the information in the prior and new test.","type":"unstyled","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"8fpja","text":"","type":"unstyled","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"1aq2h","text":"Test generation with LLMs encounters errors in generation, usually leading to compilation failures. We use a basic iterative approach to fix compilation errors but it is possible to run into errors.","type":"unstyled","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"50sr3","text":"Project Timeline","type":"header-one","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"6uajv","text":"A rudimentary version of the algorithm is currently functional. The next steps involve testing the improvement in a manual analysis of LLM output. We then write the automated test generation aspect to increase tests to a large number of bugs. Finally, we will write the failing test search algorithm.","type":"unstyled","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"e5280","text":"","type":"unstyled","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"ab2nj","text":"","type":"unstyled","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"4fhhi","text":"","type":"unstyled","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"a0d08","text":"","type":"unstyled","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"ej7lp","text":"[1]: You Cannot Fix What You Cannot Find!","type":"unstyled","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"3ungt","text":"[2]: Improving test suites for efficient fault localization","type":"unstyled","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"dsa6m","text":"[3]: ChatUniTest - A Framework for LLM-Based Test Generation","type":"unstyled","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"vd67","text":"[4]: HITS - High-coverage LLM-based Unit Test Generation via Method Slicing","type":"unstyled","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"6cs4c","text":"[5]: LLM-based Unit Test Generation via Property Retrieval","type":"unstyled","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"1ripr","text":"[6]: A Quantitative and Qualitative Evaluation of LLM-Based Explainable Fault Localization","type":"unstyled","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"8eh96","text":"[7]: SoapFL - A Standard Operating Procedure for LLM Based Method-Level Fault Localization","type":"unstyled","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"ahnt3","text":"[8]: COSMosFL - Ensemble of Small Language Models for Fault Localization","type":"unstyled","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"ckqbs","text":"[9]: Boosting Coverage-Based Fault Localization via Graph-Based Representation Learning","type":"unstyled","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"bottv","text":"[10]: YATE - The Role of Test Repair in LLM-Based Unit Test Generation","type":"unstyled","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}}]}